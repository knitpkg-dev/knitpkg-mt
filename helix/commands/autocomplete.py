# helix/commands/autocomplete.py
from typing import Union
from pathlib import Path
from helix.core.models import load_helix_manifest, MQLProjectType
from rich.console import Console

console = Console()


def navigate_path(source: Union[str, Path], target: Union[str, Path]) -> Path:
    """
    Return POSIX-style relative path from source directory to target path.
    Works automatically even when source and target are in different branches.
    
    Args:
        source: Starting path (file or directory)
        target: Destination path (file or directory)
    
    Returns:
        Relative path using forward slashes (e.g. '../../../sibling/dir/file')
    """
    src = Path(source).resolve()
    dst = Path(target).resolve()

    # Find deepest common ancestor
    common = next((p for p in src.parents if p in dst.parents), Path(src.root))

    # Count how many levels up from source to reach common ancestor
    up_levels = len(src.parents) - len(common.parents)

    # Build relative path: go up + go down into target
    rel = Path("../" * up_levels) / dst.relative_to(common)

    return rel  # Use / instead of \, standard in most codebases


def autocomplete_command():
    manifest = load_helix_manifest()
    
    if manifest.type != MQLProjectType.INCLUDE:
        console.log("[red]Error:[/] Command `helix autocomplete` only works on projects with type: include")
        raise SystemExit(1)

    console.log(f"[bold magenta]helix autocomplete[/] → generating autocomplete file for [cyan]{manifest.name}[/]")

    # Resolve dependências (reusa a mesma lógica do mkinc)
    from helix.commands.mkinc import download_dependency, ResolvedDeps
    resolved_deps: ResolvedDeps = []
    for name, spec in (manifest.dependencies or {}).items():
        download_dependency(name, spec, resolved_deps)

    # Gera o arquivo
    autocomplete_dir = Path("helix/autocomplete")
    autocomplete_dir.mkdir(parents=True, exist_ok=True)
    output_file = autocomplete_dir / "autocomplete.mqh"

    lines = [
        "//+------------------------------------------------------------------+",
        "//|                                          autocomplete.mqh        |",
        "//|              Generated by `helix autocomplete` — DO NOT EDIT     |",
        "//+------------------------------------------------------------------+",
        ""
    ]

    seen_paths = set()
    for _dep_name, dep_path in resolved_deps:
        include_dir = dep_path / "helix" / "include"
        if include_dir.exists():
            for mqh in include_dir.rglob("*.mqh"):
                rel_path = navigate_path(Path.cwd() / "helix" / "autocomplete", mqh)
                if str(rel_path) not in seen_paths:
                    lines.append(f'#include "{rel_path.as_posix()}"')
                    seen_paths.add(str(rel_path))



    output_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
    console.log(f"[bold green]Check[/] Autocomplete file generated → [bold]{output_file}[/]")

# ==============================================================
# CLI REGISTRATION
# ==============================================================

def register(app):
    @app.command()
    def autocomplete():
        """Prepare include: create autocomplete.mqh to aid the includes development."""
        autocomplete_command()    