Agora crie o arquivo docs/concepts/composite-packages.md. Você sempre deve escrever tudo em inglês. Neste documento você deve explicar o que são Composite packages. Vou colocar abaixo as explicações necessárias para o conteúdo que vc vai criar. Quando vc encontrar texto delimitado por <INSTRUCOES> e </INSTRUCOES>, isto significa que você deve interpretar e seguir estas instruções, não encare isso como conteúdo para gerar o documento. Siga o estilo de escrita dos demais arquivos em docs/concepts/*.md e não esqueça de sempre renderizar o markup com texto plano e trocando ``` por '''.

Um "composite package" é um package que depende de outros packages, enquanto um "single package" é auto contido e não depende de nenhum outro. O leitor atento observou que @douglasrechia/calc depende de @douglasrechia/bar e que ambos são packages. Portanto `calc` é um composite package e `bar` é um single package pois este último não declara nenhuma dependência. Um composite package pode depender de um ou mais packages, seja direta ou indiretamente. Um package só pode depender de outro package, e nunca de um indicator, expert, etc.

## Dependências indiretas e solução de conflitos de versão com `override`

Dependência direta: calc depende de bar. Isso é uma dependência direta.
Dependência indireta: sma depende de calc e calc depende de bar. sma depende indiretamente de bar.

Em resultado das dependências indiretas, o KnitPkg cria uma árvore de resolução de dependências, onde nunca haverá referências circulares ou referências duplicadas para o mesmo package. Um package só aparecerá na árvore de resolução de dependências uma única vez. E isso acontece porque durante o comando install o KnitPkg ignora os pacotes que já foram resolvidos e que repetirem durante a visita às dependências (que ocorre de forma recursiva).

Isso tem várias implicações. Cada package individual será incluído no flattened header ou no diretório include uma única vez, mesmo que este package apareça mais de uma vez com versões diferentes na árvore de dependências. Se isso acontecer, a versão da primeira ocorrência daquele package durante a resolução de dependências recursiva é a que vai prevalecer. Caso você queira "forçar" que um determinado package use uma versão específica, você deve adicionar uma entrada no manifest em `overrides`.

## Single packages

Vamos focar agora em [`bar`](https://forge.mql5.io/DouglasRechia/bar/src/commit/1b865e19fcfbbb907a6aa3f95a9ff4812181bcc8) como exemplo de Single package. 

Nota: conforme é esperado em um package, o código fonte está em `knitpkg/include/douglasrechia/bar`, sendo que `douglasrechia` é o nome da organization e `bar` é o nome do projeto. O nome da organization é obrigatoriamente igual ao nome da organization que vem no path do repositório git, sempre normalizado para letras minúsculas. Neste caso, como a URL do repositório é https://forge.mql5.io/DouglasRechia/bar, o nome da organization precisa ser `douglasrechia`. O mesmo não acontece com o nome do projeto: o KnitPackage não obriga que o nome do projeto que o identifica seja igual ao nome do repositório (o último elemento no path do repositório git).

### Dependências entre headers no mesmo package

Se um header (.mqh) depende de outro que está no mesmo package, pode-se incluir a dependência com o include regular MQL. Veja abaixo o exemplo:

```mql5 title="knitpkg/include/douglasrechia/bar/Bar.mqh" linenums="15"
#include "TimeSeries.mqh"
```

Observe que Bar.mqh inclui TimeSeries.mqh. O include é simples contém apenas o nome do arquivo TimeSeries sem nenhum modificador de caminho, pois ambos arquivos estão localizados no mesmo diretório. Este é o caso mais simples. Se o package tivesse headers em subdiretórios de bar, basteria usar o #include simples com o modificador de caminho relativo.

## Composite packages

### Dependências entre headers em outros packages

Vamos focar agora em [`calc`](https://forge.mql5.io/DouglasRechia/calc/src/commit/872acdff4e75df867700cd0edb389067434a0dc6) como exemplo de Composite package. Vamos ver primeiro como [`knitpkg/include/douglasrechia/calc/Calc.mqh`](https://forge.mql5.io/DouglasRechia/calc/src/commit/872acdff4e75df867700cd0edb389067434a0dc6/knitpkg/include/douglasrechia/calc/Calc.mqh) aponta para headers que estão em outros packages.


```mql5  linenums="20" hl_lines="7 15-16" title="Calc.mqh"
//------------------------------------------------------------------
// Development autocomplete — resolves dependencies and enables
// MetaEditor IntelliSense; automatically neutralized by KnitPkg 
// installer.
// Run `kp autocomplete` to regenerate.
//------------------------------------------------------------------
#include "../../../autocomplete/autocomplete.mqh"


//------------------------------------------------------------------
// KnitPkg include directives — used by KnitPkg installer at the time 
// this package is installed as a dependency into another KnitPkg 
// project.
//------------------------------------------------------------------
/* @knitpkg:include "douglasrechia/bar/TimeSeries.mqh" */
/* @knitpkg:include "douglasrechia/bar/Bar.mqh" */
```

Observe no destaque acima o #include para um arquivo que não está no repositório: `autocomplete.mqh`. Este arquivo é gerado com o comando `kp autocomplete`. Veja abaixo como ele se parece:

```mql5 linenums="1" title="Generated knitpkg/autocomplete/autocomplete.mqh"
//+------------------------------------------------------------------+
//|                                          autocomplete.mqh        |
//|              Generated by `kp autocomplete` — DO NOT EDIT     |
//+------------------------------------------------------------------+

#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/Bar.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/BarArray.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/BarMqlRates.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/BarTimeSeries.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/BarWatcher.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/TimeSeries.mqh"
#include "../../.knitpkg/cache/@douglasrechia_bar/knitpkg/include/douglasrechia/bar/TimeSeriesArray.mqh"
```

O autocomplete na verdade é um "ponteiro" para todos os headers encontrados nas dependências dentro do cache. O objetivo é que o desenvolvedor não tenha problemas ao codificar um Composite package, pois ele precisará usar as dependências diretas e indiretas enquanto codifica o package. 

Observe que `Calc.mqh` inclui `TimeSeries.mqh` e `Bar.mqh`, mas ambos estão localizados em outro package, o `bar`. Para isso, o include é feito usando a diretiva especial `@knitpkg:include`, que é processada pelo KnitPkg durante a instalação. O caminho usado na diretiva é o caminho relativo a partir do diretório `knitpkg/include/` onde os headers dos pacotes são instalados.

