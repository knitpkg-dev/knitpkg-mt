from typing import Optional, List
from pathlib import Path

from knitpkg.mql.models import ProjectType, MQLKnitPkgManifest
from knitpkg.core.file_reading import load_knitpkg_manifest
from knitpkg.core.path_helper import navigate_path
from knitpkg.mql.constants import INCLUDE_DIR
from knitpkg.core.console import Console, ConsoleAware

# Import MQL-specific downloader
from knitpkg.core.dependency_downloader import ProjectNode
from knitpkg.mql.dependency_downloader import MQLDependencyDownloader
from knitpkg.core.global_config import get_registry_url
from knitpkg.core.exceptions import InvalidUsageError

# ==============================================================
# AUTOCOMPLETE GENERATOR CLASS
# ==============================================================

class AutocompleteGenerator(ConsoleAware):
    """Generates autocomplete files for MQL package projects."""

    def __init__(self, project_dir: Path, console: Optional[Console] = None, verbose: bool = False):
        """
        Initialize the AutocompleteGenerator.

        Args:
            console: Rich console for output
            project_dir: Root directory of the KnitPkg project
        """
        super().__init__(console, verbose)
        self.project_dir = project_dir

    def generate(self) -> None:
        """
        Generate the autocomplete.mqh file.

        This file includes all MQL header files from the project's
        dependencies, making them available for autocompletion
        in MetaEditor.
        """
        manifest: MQLKnitPkgManifest = load_knitpkg_manifest(
            self.project_dir,
            manifest_class=MQLKnitPkgManifest
        )

        self.print(
                f"üìù [bold green]Autocomplete[/bold green] ‚Üí "
                f"[cyan]@{manifest.organization}/{manifest.name}[/cyan] : {manifest.version}"
            )

        if manifest.type != ProjectType.PACKAGE:
            raise InvalidUsageError("Command `kp-mt autocomplete` only works on projects with type: package")

        # Resolve dependencies (reuse same logic as install)
        resolved_deps: List[ProjectNode] = []
        if manifest.dependencies:
            registry_url = get_registry_url()
            downloader = MQLDependencyDownloader(self.project_dir, registry_url, False, MQLKnitPkgManifest, console=self.console, verbose=self.verbose)
            project_root = downloader.download_all()
            resolved_deps = project_root.resolved_nodes()
        else:
            self.print(
                "[yellow]‚ö†Ô∏è  Warning:[/] No dependencies found in manifest. "
                "Autocomplete file will be empty."
            )

        # Generate the file
        autocomplete_dir = self.project_dir / "knitpkg" / "autocomplete"
        autocomplete_dir.mkdir(parents=True, exist_ok=True)
        output_file = autocomplete_dir / "autocomplete.mqh"

        lines = [
            "//+------------------------------------------------------------------+",
            "//|                                          autocomplete.mqh        |",
            "//|              Generated by `kp-mt autocomplete` ‚Äî DO NOT EDIT     |",
            "//+------------------------------------------------------------------+",
            ""
        ]

        seen_paths = set()
        for node in resolved_deps:
            dep_path = node.resolved_path
            include_dir = dep_path / INCLUDE_DIR
            if include_dir.exists():
                for mqh in include_dir.rglob("*.mqh"):
                    rel_path = navigate_path(
                        autocomplete_dir,
                        mqh
                    )
                    if str(rel_path) not in seen_paths:
                        lines.append(f'#include "{rel_path.as_posix()}"')
                        seen_paths.add(str(rel_path))

        output_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
        self.print(
            f"[bold green]‚úÖ Autocomplete file generated[/bold green] ‚Üí {output_file.relative_to(self.project_dir).as_posix()}"
        )
